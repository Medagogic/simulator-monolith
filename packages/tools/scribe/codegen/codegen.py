from typing import Dict, List
from pydantic import BaseModel
from packages.server.sim_app.medsim import Router_MedSim, Session_MedSim
import json
import os
from pathlib import Path
import re
from packages.tools.scribe import ScribeEmitSchema
from packages.tools.scribe.src.scribe_helpers import get_field_info
import asyncio

def generate_code(verbose=False) -> None:
    this_file = Path(os.path.realpath(__file__))
    this_dir = this_file.parent
    schema_dir = f"{this_dir}/schemas"
    generated_dir = f"{this_dir}/generated"

    event_datas: List[ScribeEmitSchema] = Router_MedSim.scribe_get_all_emitted_events(Session_MedSim)

    schema_properties: Dict[str, Dict] = {}

    for event_data in event_datas:
        if event_data.data_type is not None and issubclass(event_data.data_type, BaseModel):
            schema = event_data.data_type.model_json_schema()
            filename = f"{schema['title']}.schema.json"
            schema["$id"] = filename
            schema["additionalProperties"] = False
            with open(f"{schema_dir}/{filename}", "w") as f:
                json.dump(schema, f, indent=4)
            schema_properties[event_data.emits_event] = {"$ref": f"schemas/{filename}"}
        else:
            schema_properties[event_data.emits_event] = get_field_info(event_data.data_schema)

    required_fields = [event_data.emits_event for event_data in event_datas]

    schema_dict = {
        "$id": "Scribe Events",
        "$schema": "http://json-schema.org/schema#",
        "type": "object",
        "properties": schema_properties,
        "additionalProperties": False,
        "required": required_fields
    }

    with open(f"{schema_dir}/scribe.schema.json", "w") as f:
        json.dump(schema_dict, f, indent=4)


    # run generate_events.sh
    import subprocess
    subprocess.run(["bash", f"{this_dir}/generate_events.sh"])

    prompt = """
    Create an abstract typescript class `ScribeClient` which provides virtual functions for each element in ScribeEvents, with a single paramater "data" of the associated type. Do not provide any surrounding text, provide only the code.

    For example:
    export interface ScribeEvents {
    another_function: DummyType;
    another: null;
    test_function: Object;
    }

    You should generate the code:
    import { DummyType } from "./scribetypes";

    export abstract class ScribeClient {
    socket: Socket;
    abstract on_another_function(data: DummyType): void;
    abstract on_another(): void;
    abstract on_test_function(data: Object): void;

    constructor(socket: Socket) {
        this.socket = socket;
        this.socket.on("another_function", (data: DummyType) => this.on_another_function(data));
        this.socket.on("another", () => this.on_another());
        this.socket.on("test_function", (data: Object) => this.on_test_function(data));
    }
    }

    Generate the code for the following ScribeEvents object:

    <SCHEMA>
    """

    ts_file_path = f"{generated_dir}/scribetypes.d.ts"

    with open(ts_file_path, "r") as f:
        ts_file_contents = f.read()

    # Regular expression to extract the ScribeEvents interface content
    pattern = re.compile(r'(export interface ScribeEvents \{.*?\})', re.DOTALL)


    # Search for the pattern
    match = pattern.search(ts_file_contents)

    if not match:
        raise Exception("Could not find ScribeEvents interface in scribetypes.d.ts")
        
    sio_events_content = match.group(1)

    formatted_prompt = prompt.replace("<SCHEMA>", sio_events_content)


    from packages.server.gpt.gpt_api import gpt, MODEL_GPT35, GPTMessage, Role

    async def main():
        show_progress="Generating ScribeClient..."
        if not verbose:
            show_progress = False
        response = await gpt([GPTMessage(role=Role.USER, content=formatted_prompt)], model=MODEL_GPT35, show_progress=show_progress)

        generated_ts_content = """
    /* eslint-disable */
    /**
    * This file was automatically generated by Scribe's codegen tool.
    * This class was generated by GPT3.5, so godspeed and good luck.
    */

    import { Socket } from "socket.io";
    <CLASS>
    """.strip().replace("<CLASS>", response)

        if not os.path.exists(generated_dir):
            os.mkdir(generated_dir)

        with open(f"{generated_dir}/ScribeClient.ts", "w") as f:
            f.write(generated_ts_content)
        with open(f"{generated_dir}/scribetypes.d.ts", "w") as f:
            f.write(ts_file_contents)

        frontend_folder = "packages/frontend/src/scribe"
        import shutil
        shutil.move(f"{generated_dir}/ScribeClient.ts", f"{frontend_folder}/ScribeClient.ts")
        shutil.move(f"{generated_dir}/scribetypes.d.ts", f"{frontend_folder}/scribetypes.d.ts")

        # remove generated_dir
        shutil.rmtree(generated_dir)

        print(f"Generated Scribe interface in frontent/src/scribe")

    asyncio.run(main())



if __name__ == "__main__":
    generate_code(verbose=True)